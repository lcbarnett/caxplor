#include "rtab.h"
#include "utils.h"

/*********************************************************************/
/*              rule table (double-linked) list                         */
/*********************************************************************/

rtl_t* rtl_add(rtl_t* curr, const int B) // insert after
{
	if (curr == NULL) { // empty list
		curr = malloc(sizeof(rtl_t));
		PASSERT(curr != NULL,"memory allocation failed");
		curr->next = NULL;
		curr->prev = NULL;
	}
	else {
		rtl_t* const newprev = curr;
		rtl_t* const newnext = curr->next;
		curr = malloc(sizeof(rtl_t));
		PASSERT(curr != NULL,"memory allocation failed");
		curr->next = newnext;
		curr->prev = newprev;
		newprev->next = curr;
		if (newnext != NULL) newnext->prev = curr; // not at end of list
	}
	curr->filt = NULL;
	curr->rtab = rt_alloc(B);
	return curr;
}

rtl_t* rtl_del(rtl_t* curr)
{
	if (curr == NULL) return NULL; // nothing to delete
	rtl_t* const oldcurr = curr;
	if (oldcurr->next == NULL) { // end of list
		if (oldcurr->prev == NULL) { // only 1 item in list!
			curr = NULL;
		}
		else {
			curr = oldcurr->prev;
			curr->next = NULL;
		}
	}
	else {
		curr = oldcurr->next;
		if (oldcurr->prev == NULL) { // beginning of list
			curr->prev = NULL;
		}
		else {
			curr->prev = oldcurr->prev;
			oldcurr->prev->next = curr;
		}
	}
	free(oldcurr->rtab);
	rtl_free(oldcurr->filt);
	return curr;
}

void rtl_free(rtl_t* curr)
{
	while (curr != NULL) curr = rtl_del(curr);
}

/*********************************************************************/
/*                      rule table                                   */
/*********************************************************************/

word_t* rt_alloc(const int B)
{
	ASSERT(B<WBITS,"rule too wide");
	word_t* const rtab = calloc(POW2(B),sizeof(word_t)); // note: zero initialises (this is fine)
	PASSERT(rtab != NULL,"memory allocation failed");
	return rtab;
}

void rt_randomb(const int B, word_t* const rtab, const size_t b, mt_t* const prng)
{
	const size_t S = POW2(B);
	ASSERT(b<=S,"too many bits");
	memset(rtab,0,S*sizeof(word_t));
	for (size_t i=0; i<b; ++i) rtab[i] = WONE;
	for (size_t i=0; i<b; ++i) {
		size_t j = i+RANDI(size_t,S-i,prng);
		const word_t tmp = rtab[i];
		rtab[i] = rtab[j];
		rtab[j] = tmp;
	}
}

size_t rt_uwords(const int B, const word_t* const rtab,const int m)
{
	// Find the number of unique words generated by rule rtab of breadth B
	// operating on all words of length m.
	const size_t M = POW2(m);
	const int WB  = WBITS-B;
	const int Wm  = WBITS-m;
	const int WBm = WB+m;
	if (m > WBITS) EEXIT("word too long!");
	word_t* const w = mw_alloc(M);
	for (word_t v=0;v<M;++v) {
		word_t wv = 0;
		int i = 0;
		for (;i<m-B+1;++i) PUTBIT(wv,i,rtab[(v<<(WB-i))>>WB]);
		for (;i<m    ;++i) PUTBIT(wv,i,rtab[((v<<Wm)>>(Wm+i))|((v<<(WBm-i))>>WB)]);
		w[v] = wv;
	}
	size_t n = 1;
	for (size_t v=1;v<M;++v) {
		size_t u = 0;
		for (;u<v;++u) if (w[u] == w[v]) break;
		if (u == v) ++n;
	}
	free(w);
	return n;
}

void rt_to_mwords(const int B, const word_t* const rtab, const size_t nrtwords, word_t* const rtwords)
{
	ASSERT(nrtwords == rt_nwords(B),"Wrong number of words!");
	const size_t S = POW2(B);
	word_t* p = rtwords;
	*p = WZERO;
	int i = 0;
	for (size_t r=0;r<S;++r) {
		PUTBIT(*p,i,rtab[r]);
		if (++i == WBITS) {*(++p) = WZERO; i = 0;}
	}
}

void rt_from_mwords(const int B, word_t* const rtab, const size_t nrtwords, const word_t* const rtwords)
{
	ASSERT(nrtwords == rt_nwords(B),"Wrong number of words!");
	const size_t S = POW2(B);
	const word_t* p = rtwords;
	int i = 0;
	for (size_t r=0;r<S;++r) {
		rtab[r] = BITON(*p,i);
		if (++i == WBITS) {++p; i = 0;}
	}
}

void rt_fprint(const int B, const word_t* const rtab, FILE* const fstream)
{
	const size_t S = POW2(B);
	for (size_t r=0;r<S;++r) fprintf(fstream,"%3zu = "PBP08" -> %"PRIw"\n",r,PBI08(r),rtab[r]);
}

void rt_print(const int B, const word_t* const rtab)
{
	rt_fprint(B,rtab,stdout);
}

void rt_fprint_id(const int B, const word_t* const rtab, FILE* const fstream)
{
	const size_t S = POW2(B);
	word_t u = 0;
	int i = 0;
	for (size_t r=0;r<S;++r) {
		PUTBIT(u,i,rtab[r]);
		if ((++i)%4 == 0) {
			fputc(hexchar[u],fstream);
			u = 0;
			i = 0;
		}
	}
}

void rt_print_id(const int B, const word_t* const rtab)
{
	rt_fprint_id(B,rtab,stdout);
}

int rt_fread_id(const int B, word_t* const rtab, FILE* const fstream)
{
	const size_t C = rt_hexchars(B);
	char* xstr = NULL;
	size_t len = 0;
	const ssize_t ilen = getline(&xstr,&len,fstream);
	ASSERT(ilen != -1,"Read failed.");
	if ((size_t)ilen != C+1) { // failure - wrong number of chars
		free(xstr);
		return 1;
	}
	size_t r = 0;
	for (size_t c=0;c<C;++c) {
		const char x = xstr[c];
		const word_t u = (word_t)((x >= '0') & (x <= '9') ? x-48 : (x >= 'A') & (x <= 'F') ? x-55 : 0);
		if (u == 0) { // failure - non-hex chars
			free(xstr);
			return 2;
		}
		for (int i=0;i<4;++i) rtab[r++] = BITON(u,i);
	}
	free(xstr);
	return 0; // success
}

int rt_read_id(const int B, word_t* const rtab)
{
	return rt_fread_id(B,rtab,stdin);
}

void rt_entro_hist(const int B, const word_t* const rtab, const int m, const int iff, ulong* const bin)
{
	// Entropy histogram for CA rule on sequence of length m after iter iterations

	const size_t S = (size_t)POW2(m);
	for (word_t x=WZERO; x<S; ++x) {
		word_t y = x;
		for (int i=0; i<iff; ++i) y = wd_filter(m,y,B,rtab); // advance CA (at least 1)
		++bin[y];
	}
}

double rt_entro(const int B, const word_t* const rtab, const int m, const int iff)
{
	// Entropy for CA rule on sequence of length m after iter iterations

	const   size_t S   = (size_t)POW2(m);
	ulong*  const  bin = calloc(S,sizeof(ulong)); // zero-initialises
	PASSERT(bin != NULL,"memory allocation failed");
	rt_entro_hist(B,rtab,m,iff,bin);
	double* const  p = malloc(S*sizeof(double));
	PASSERT(p != NULL,"memory allocation failed");
	const   double f = 1.0/(double)S;
	for (size_t y=0; y<S; ++y) p[y] = f*(double)bin[y];
	const double H = entro2(S,p);
	free(p);
	free(bin);
	return H;
}

void rt_trent1_hist(const int B, const word_t* const rtab, const int F, const word_t* const ftab, const int m, const int iff, const int ilag, ulong* const bin, ulong* const bin2)
{
	// 1-lag transfer entropy histograms for CA rule and filter rule on sequence of length m after iter iterations

	const size_t S = (size_t)POW2(m);
	for (word_t x=WZERO; x<S; ++x) {
		word_t y = x;
		for (int i=0; i<iff; ++i) y = wd_filter(m,y,B,rtab);  // advance CA (may be zero)
		const word_t u = wd_filter(m,y,F,ftab);               // filter CA
		++bin[u];
		for (int i=0; i<ilag; ++i) y = wd_filter(m,y,B,rtab); // advance CA (at least 1)
		const word_t v = wd_filter(m,y,F,ftab);               // filter CA
		++bin2[u+S*v];
	}
}

double rt_trent1(const int B, const word_t* const rtab, const int F, const word_t* const ftab, const int m, const int iff, const int ilag)
{
	// 1-lag transfer entropy for CA rule and filter rule on sequence of length m after iter iterations

	const   size_t S    = (size_t)POW2(m);
	ulong*  const  bin  = calloc(S,sizeof(ulong)); // zero-initialises
	PASSERT(bin != NULL,"memory allocation failed");
	const   size_t S2   = (size_t)POW2(2*m);
	ulong*  const  bin2 = calloc(S2,sizeof(ulong)); // zero-initialises
	PASSERT(bin2 != NULL,"memory allocation failed");
	rt_trent1_hist(B,rtab,F,ftab,m,iff,ilag,bin,bin2);
	double* const  p = malloc(S*sizeof(double));
	PASSERT(p != NULL,"memory allocation failed");
	const   double f = 1.0/(double)S;
	for (size_t y=0; y<S; ++y) p[y] = f*(double)bin[y];
	const double H = entro2(S,p);
	double* const  p2 = malloc(S2*sizeof(double));
	PASSERT(p2 != NULL,"memory allocation failed");
	for (size_t y2=0; y2<S2; ++y2) p2[y2] = f*(double)bin2[y2];
	const double H2 = entro2(S2,p2);
	free(p2);
	free(p);
	free(bin2);
	free(bin);
	return H2-H;
}
